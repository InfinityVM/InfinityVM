# v0 Coprocessor Tutorial

This document outlines how to operate all necessary components of the
Ethos v0 coprocessor, submit programs, create and query for jobs.

Note, the v0 version of the coprocessor is broken down into two disparate
components:

* The coprocessor server
  * The server is responsible for allowing clients to create programs, submit
    and query for jobs. In addition, it also relays completed jobs, i.e. their
    results to the rollup chain.
* The ZK shim
  * The ZK shim is responsible for executing jobs against the ZK VM. It only
    receives requests from the server itself and is not meant to communicate
    with the outside world.

In the next iteration of the coprocessor, these components will be unified.

## Contracts

You can read more on how to deploy and interact with the coprocessor contracts in Anvil in `contracts/README.md`.

All CLI commands for interacting with contracts along with relevant comments and parameters are listed in `contracts/Makefile`.

## Rollup Chain

<!-- TODO: Describe how to spin up rollup and deploy necessary contract(s) -->

## Coprocessor

Before proceeding, you must have both the Golang and Rust toolchains installed.

Clone the coprocessor git repository:

```shell!
$ git clone git@github.com:Ethos-Works/InfinityVM.git
```

### ZK Shim

> Note: before proceeding, you must have RISC Zero installed. Please see [here](https://dev.risczero.com/api/zkvm/install)
for instructions.

First, build the shim's dependencies:

```shell!
$ cd rust && cargo build
```

To start the ZK shim server:

```shell!
$ cargo run -p executor -- --ip 127.0.0.1 --port 3001 dev
```

### Anvil
> Note: A local instance of Anvil must be running with the deployed contracts as a prerequisite of running the server.

Generate chain state by running:
```shell!
make deploy-coprocessor-contracts-to-anvil-and-save-state
```

Start Anvil
```shell!
make  start-anvil-chain-with-coprocessor-deployed
```

Export the JobManager contract address needed to start the relayer:
```shell!
export CONTRACT_ADDR=$(make print-relayer-address)
```

### Server

First, build the coprocesser server binary:

```shell!
$ cd server && make build
```

Before starting the server, you must export the relayer's private key.

The default private key is `0c7ec7aefb80022c0025be1e72dadb0679aa294cb1db453b2e7b5da8616b4e31`

```shell!
export RELAYER_PRIVATE_KEY=...
```

Export the Eth RPC endpoint
```shell!
export ETH_RPC=127.0.0.1:8545
```

To start the coprocesser server:

```shell!
$ ./build/infinity-server \
    --zk-shim-address localhost:3001 \
    --job-manager-address $CONTRACT_ADDR \
    --eth-rpc-address $ETH_RPC
```

### Programs and Jobs

Now that the rollup, ZK shim and server are running, you can submit programs and jobs.

#### Submit a Program

Before you can submit a coprocessing job to perform some compute, you must first
submit a ZK program. This is done by compiling the ZK program to its ELF format
and then submitting that to the server to get a verifying key as a response.

This verifying key is crucial to program execution as it uniquely identifies the
program and must be used for all jobs executing against it.

In this example, we are using the vapenation ZK program, which is compiled for the
RISC Zero VM.

```shell
$ http POST 127.0.0.1:8080/v1/server/submit_program vmType=Risc0 programElf=@/path/to/vapenation_guest.enc
HTTP/1.1 200 OK
Content-Length: 70
Content-Type: application/json
Date: Mon, 15 Jul 2024 17:22:43 GMT

{
    "programVerifyingKey": "MQR87qXOAEar622rRGMZ0pQv/vdX+7TZVRpS/ugy8hs="
}
```

The response contains a `programVerifyingKey` which is tied to the compiled ELF ZK program.

#### Submit a Job

To submit a job for execution, you'll need a few inputs. Namely:

* `programVerifyingKey`: The program's verifying key, generated in the previous step. Note, this only needs to be done once.
* `maxCycles`: The maximum number of cycles that can be executed by the ZK VM. In this example program, we can use 10000000.
* `contractAddress`: The rollup contract address where the result is expected to be submitted to via a callback.
* `id`: The job ID, which is typically generated by the rollup. However, in this example we'll use a dummy value of 1.
* `input`: The encoded input which is provided into the job's execution. For this example program, the input is hard-coded.

To execute a job with these inputs:

```shell
$ http POST 127.0.0.1:8080/v1/server/submit_job \
    'job[programVerifyingKey]=MQR87qXOAEar622rRGMZ0pQv/vdX+7TZVRpS/ugy8hs=' \
    'job[maxCycles]:=10000000' \
    'job[contractAddress]=<0x...>' \
    'job[id]:=1' \
    'job[input]=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI='
HTTP/1.1 200 OK
Content-Length: 11
Content-Type: application/json
Date: Mon, 15 Jul 2024 17:27:41 GMT

{
    "jobId": 1
}
```

The response contains a `jobId`, which can be used to query for the job's status.

#### Query a Job

To query for a job via it's `jobId`:

```shell
$ http GET 127.0.0.1:8080/v1/server/result/1
HTTP/1.1 200 OK
Content-Length: 885
Content-Type: application/json
Date: Mon, 15 Jul 2024 17:32:43 GMT

{
    "job": {
        "contractAddress": "...",
        "id": 1,
        "input": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI=",
        "maxCycles": "10000000",
        "programVerifyingKey": "MQR87qXOAEar622rRGMZ0pQv/vdX+7TZVRpS/ugy8hs=",
        "result": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAV4f6Eqgj4PK3YxzEGzuogoszIcqBERH6dc06o7tazgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmJaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgMQR87qXOAEar622rRGMZ0pQv/vdX+7TZVRpS/ugy8hsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJuWDBWB8nU5ldmVyRm9yZ2V0NDIwIE5ldmVyRm9yZ2V0NDIwghPyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
        "status": "JOB_STATUS_DONE",
        "vmType": "Risc0",
        "zkvmOperatorAddress": "MHhhMEVlN0ExNDJkMjY3QzFmMzY3MTRFNGE4Rjc1NjEyRjIwYTc5NzIw",
        "zkvmOperatorSignature": "gKBc9XcCqTrn8b39Vm6TvgvJdU5GXBQFwfzV5wM0q2VPKaBUG/FlO/6m+ZuUYzWS2aIt6K9rweR/jdDjb5ty0KS19w=="
    }
}
```