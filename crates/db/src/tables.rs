//! Database tables

use alloy::rlp::bytes;
use borsh::{BorshDeserialize, BorshSerialize};
use proto::JobStatus;
use reth_db::{
    table::{Compress, Decode, Decompress, Encode},
    tables, DatabaseError, TableType, TableViewer,
};
use sha2::{Digest, Sha256};
use std::fmt;

// Job used internally and stored in DB
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, BorshSerialize, BorshDeserialize)]
pub struct Job {
    // The job ID (hash of nonce and consumer address).
    pub id: [u8; 32],
    // Nonce of the job request for a given consumer contract
    pub nonce: u64,
    // CPU cycle limit for job execution
    pub max_cycles: u64,
    // The address of the contract to execute a callback with a result with
    pub consumer_address: Vec<u8>,
    // The ZK program verification key
    pub program_id: Vec<u8>,
    // Program execution input
    pub input: Vec<u8>,
    // Signature on the offchain job request
    pub request_signature: Vec<u8>,
    // The result of job execution
    pub result: Vec<u8>,
    // The signature of the operator that executed the job
    pub zkvm_operator_signature: Vec<u8>,
    // The status of the job.
    pub status: JobStatus,
}


message JobResult {
    // The job ID generated by the InfinityVM chain.
    bytes id = 1;
    // Nonce of the job request for a given consumer contract
    uint64 nonce = 2;
    // CPU cycle limit for job execution
    uint64 max_cycles = 3;
    // The address of the contract to execute a callback with a result with
    // This address is not zero-padded
    bytes consumer_address = 4;
    // The ZK program verification key
    bytes program_id = 5;
    // Program execution input
    bytes input = 6;
    // Signature on the offchain job request
    bytes request_signature = 7;
    // ABI-encoded result of job execution with metadata
    // Onchain job result: tuple(JobID,ProgramInputHash,MaxCycles,VerifyingKey,RawOutput)
    // Offchain job result: tuple(ProgramInputHash,MaxCycles,VerifyingKey,RawOutput)
    bytes result_with_metadata = 8;
    // The signature of the operator that executed the job
    bytes zkvm_operator_signature = 9;
    // The status of the job.
    JobStatus status = 10;
  }

  /// tuple(JobID,ProgramInputHash,MaxCycles,VerifyingKey,RawOutput)
pub type ResultWithMetadata = sol! {
    tuple(bytes32,bytes32,uint64,bytes,bytes)
};

/// The payload that gets signed to signify that the zkvm executor has faithfully
/// executed an offchain job. Also the result payload the job manager contract expects.
///
/// tuple(ProgramInputHash,MaxCycles,VerifyingKey,RawOutput)

  

impl Compress for Job {
    type Compressed = Vec<u8>;
    fn compress_to_buf<B: bytes::BufMut + AsMut<[u8]>>(self, dest: &mut B) {
        let src = borsh::to_vec(&self).expect("borsh serialize works. qed.");
        dest.put(&src[..])
    }
}

impl Decompress for Job {
    fn decompress<B: AsRef<[u8]>>(value: B) -> Result<Self, DatabaseError> {
        borsh::from_slice(value.as_ref()).map_err(|_| DatabaseError::Decode)
    }
}

/// Key to tables storing job metadata and failed jobs.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
pub struct JobID(pub [u8; 32]);

impl Encode for JobID {
    type Encoded = [u8; 32];

    fn encode(self) -> Self::Encoded {
        self.0
    }
}

impl Decode for JobID {
    fn decode<B: AsRef<[u8]>>(value: B) -> Result<Self, DatabaseError> {
        let inner: [u8; 32] = value.as_ref().try_into().map_err(|_| DatabaseError::Decode)?;

        Ok(Self(inner))
    }
}

/// Key to a table storing ELFs. The first byte of the key is the vm type
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
pub struct ElfKey(pub [u8; 32]);

impl ElfKey {
    /// New [Self]
    pub(crate) fn new(program_id: &[u8]) -> Self {
        let inner: [u8; 32] = Sha256::digest(program_id).into();

        Self(inner)
    }
}

impl Encode for ElfKey {
    type Encoded = [u8; 32];

    fn encode(self) -> Self::Encoded {
        self.0
    }
}

impl Decode for ElfKey {
    fn decode<B: AsRef<[u8]>>(value: B) -> Result<Self, DatabaseError> {
        let inner: [u8; 32] = value.as_ref().try_into().map_err(|_| DatabaseError::Decode)?;

        Ok(Self(inner))
    }
}

/// Storage format for elf files
#[derive(Debug, BorshSerialize, BorshDeserialize, serde::Serialize)]
pub struct ElfWithMeta {
    /// The type of vm
    pub vm_type: u8,
    /// The ELF file
    pub elf: Vec<u8>,
}

impl Compress for ElfWithMeta {
    type Compressed = Vec<u8>;
    fn compress_to_buf<B: bytes::BufMut + AsMut<[u8]>>(self, dest: &mut B) {
        let src = borsh::to_vec(&self).expect("borsh serialize works. qed.");
        dest.put(&src[..])
    }
}

impl Decompress for ElfWithMeta {
    fn decompress<B: AsRef<[u8]>>(value: B) -> Result<Self, DatabaseError> {
        borsh::from_slice(value.as_ref()).map_err(|_| DatabaseError::Decode)
    }
}

reth_db::tables! {
    /// Stores Elf files
    table ElfTable<Key = ElfKey, Value = ElfWithMeta>;
    /// Stores jobs
    table JobTable<Key = JobID, Value = Job>;
    /// Stores failed jobs
    table RelayFailureJobs<Key = JobID, Value = Job>;
}
