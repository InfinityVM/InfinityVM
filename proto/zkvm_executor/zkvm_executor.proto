syntax = "proto3";

package zkvm_executor;

service ZkvmExecutor {
  rpc execute(ExecuteRequest) returns (ExecuteResponse) {}
}

// The inputs to the zkvm program that get attested to by the zkvm operator.
message VerifiedInputs {
  // Job identifier, as defined by the ethos chain job manager contracts.
  uint32 job_id = 1;
  // The verifying key for the program. The executor needs to check
  // that this matches up with the program ELF before using it.
  bytes program_verifying_key = 2;
  // The input to the zkvm program. The zkvm program is in charge
  // of deserializing this.
  bytes program_input = 3;
  // The maximum amount of cpu cycles. In the future this may
  // be something closer to gas/opcode count.
  uint64 max_cycles = 4;
  // TODO(zeke): VM type
}

// A request to execute a zkvm program.
message ExecuteRequest {
  // The program executable
  bytes program_elf = 1;
  // The job inputs for running the program that are attested to by the executor
  // operator to assert faithful execution.
  VerifiedInputs inputs = 2;
}

// The results of executing a program
message ExecuteResponse {
  // The inputs to the program execution request. These need to be included
  // in the attested to payload to ensure that a zk proof can be constructed
  // just using the attested payload.
  VerifiedInputs inputs = 1;
  // Output of the program specified by the verified inputs.
  bytes raw_output = 2;
  // The ZKVM operator who attests to the job.
  // Ethereum address, as the bytes of an EIP-55 checksum string.
  bytes zkvm_operator_address = 3;
  // RLP v,r,s signature over
  // `eip191_hash_message(program_verifying_key|program_input|max_cycles|raw_output)`
  bytes zkvm_operator_signature = 4;
}
